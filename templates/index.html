<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <title>Spotify Graph Explorer</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <link rel="icon" href="https://upload.wikimedia.org/wikipedia/commons/1/19/Spotify_logo_without_text.svg"
        type="image/svg+xml">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>

<body>

    <div id="sidebar">
        <div>
            <h2>Spotify Graph Explorer üéµ</h2>
            <p class="subtitle">Explorador de Colabora√ß√µes</p>
        </div>

        <label>üîç Buscar Artista ou M√∫sica no Grafo</label>
        <div class="search-container">
            <input type="text" id="searchInput" list="artistSuggestions" placeholder="Digite o nome..."
                onkeypress="handleEnter(event)">
            <datalist id="artistSuggestions"></datalist>
            <button class="btn-search" onclick="searchNode()" title="Buscar">‚ûù</button>
        </div>

        <label>Artista de Origem (Start)</label>
        <select id="startSelect">
            <option>Carregando...</option>
        </select>

        <label>Artista de Destino (End)</label>
        <select id="endSelect">
            <option>Carregando...</option>
        </select>

        <label style="margin-top: 10px; display:block;">Explora√ß√£o (1 Fonte)</label>
        <div class="btn-group">
            <button class="btn-bfs" onclick="runAlgo('bfs')" title="Busca em Largura">BFS</button>
            <button class="btn-dfs" onclick="runAlgo('dfs')" title="Busca em Profundidade">DFS</button>
        </div>

        <label style="margin-top: 15px; display:block;">Caminho M√≠nimo (Start &rarr; End)</label>
        <div class="btn-group">
            <button class="btn-dijk" onclick="runAlgo('dijkstra')"
                title="Caminho mais curto (Pesos Positivos)">Dijkstra</button>
            <button class="btn-bf" onclick="runAlgo('bellman_ford')"
                title="Detecta ciclos negativos">Bellman-Ford</button>
        </div>

        <label style="margin-top: 20px; display:block;">Teste Bellman-Ford</label>
        <div class="btn-group">
            <button class="btn-toggle-neg" onclick="pesoNegativo()"
                title="Inverte o peso">Peso Negativo</button>
            <button class="btn-reset-weights" onclick="resetarPesos()"
                title="Volta aos pesos originais">Resetar Pesos</button>
        </div>

        <div id="loading" class="loader">PROCESSANDO NO PYTHON...</div>
        <div id="output">Selecione os artistas e escolha um algoritmo para come√ßar.</div>

        <button class="btn-reset" onclick="resetGraph()">Limpar / Resetar Zoom</button>
    </div>

    <div id="network"></div>
    <div class="hint">Dica: Clique nas linhas para ouvir a m√∫sica no Spotify. Duplo clique nos v√©rtices para abrir o artista no Spotify.</div>

    <script type="text/javascript">
        var network = null;
        var nodesDataset = new vis.DataSet();
        var edgesDataset = new vis.DataSet();
        var originalProcessedEdges = null; // Armazena as arestas processadas originais

        async function initGraph() {
            try {
                const response = await fetch('/api/graph');
                const data = await response.json();

                nodesDataset.add(data.nodes);
                const processedEdges = processEdges(data.edges);
                originalProcessedEdges = processedEdges; // Salva as arestas originais
                edgesDataset.add(processedEdges);

                populateSelects(data.nodes);

                var container = document.getElementById('network');
                var options = {
                    nodes: {
                        shape: 'dot',
                        size: 20,
                        font: { size: 14, color: '#ffffff', strokeWidth: 2, strokeColor: '#000' },
                        borderWidth: 2,
                        shadow: true
                    },
                    edges: {
                        width: 2,
                        color: { color: '#444', highlight: '#1DB954', hover: '#1DB954' },
                        smooth: { type: 'continuous', roundness: 0.5 },
                        selectionWidth: 3
                    },
                    physics: {
                        forceAtlas2Based: {
                            gravitationalConstant: -30,
                            centralGravity: 0.003,
                            springLength: 200,
                            springConstant: 0.08
                        },
                        maxVelocity: 50,
                        solver: 'forceAtlas2Based',
                        timestep: 0.35,
                        stabilization: { iterations: 100 }
                    },
                    interaction: {
                        hover: true,
                        tooltipDelay: 200,
                        zoomView: true,
                        dragView: true
                    }
                };

                network = new vis.Network(container, { nodes: nodesDataset, edges: edgesDataset }, options);
                setupNetworkEvents();

            } catch (error) {
                document.getElementById('output').innerText = "Erro ao carregar grafo. O servidor Python est√° rodando?";
                console.error(error);
            }
        }

        function setupNetworkEvents() {
            network.on("selectEdge", function (params) {
                if (params.edges.length > 0 && params.nodes.length === 0) {
                    var edgeId = params.edges[0];
                    var edgeData = edgesDataset.get(edgeId);

                    if (edgeData && edgeData.track_name) {
                        var query = `${edgeData.track_name} ${edgeData.artist_1} ${edgeData.artist_2}`;

                        var url = `https://open.spotify.com/search/${encodeURIComponent(query)}`;

                        document.getElementById('output').innerHTML = `üéµ Abrindo Spotify para: <br><strong>${edgeData.track_name}</strong>`;

                        window.open(url, '_blank');

                        network.unselectAll();
                    }
                }
            });

            network.on("hoverEdge", function (params) {
                document.getElementById('network').style.cursor = 'pointer';
            });
            network.on("blurEdge", function (params) {
                document.getElementById('network').style.cursor = 'default';
            });

            // Duplo clique no v√©rtice para abrir Spotify do artista
            network.on("doubleClick", function (params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var nodeData = nodesDataset.get(nodeId);
                    
                    if (nodeData && nodeData.label) {
                        var artistName = nodeData.label;
                        var url = `https://open.spotify.com/search/${encodeURIComponent(artistName)}`;
                        
                        document.getElementById('output').innerHTML = `üé§ Abrindo Spotify para o artista: <br><strong>${artistName}</strong>`;
                        
                        window.open(url, '_blank');
                        
                        network.unselectAll();
                    }
                }
            });
        }

        function populateSelects(nodes) {
            const startSelect = document.getElementById('startSelect');
            const endSelect = document.getElementById('endSelect');
            startSelect.innerHTML = ''; endSelect.innerHTML = '';

            nodes.sort((a, b) => a.label.localeCompare(b.label));

            nodes.forEach(node => {
                const opt1 = new Option(node.label, node.id);
                const opt2 = new Option(node.label, node.id);
                startSelect.add(opt1);
                endSelect.add(opt2);
            });

            if (endSelect.options.length > 1) endSelect.selectedIndex = 1;
        }

        async function runAlgo(type) {
            const startNode = document.getElementById('startSelect').value;
            const endNode = document.getElementById('endSelect').value;
            const outputDiv = document.getElementById('output');
            const loader = document.getElementById('loading');

            if ((type === 'dijkstra' || type === 'bellman_ford') && startNode === endNode) {
                outputDiv.innerHTML = "<span style='color:#e74c3c'>Erro:</span> A origem e o destino s√£o iguais.";
                return;
            }

            resetGraph(false);
            loader.style.display = 'block';
            outputDiv.innerText = "Calculando...";

            try {
                const url = `/api/run_algo?type=${type}&start=${encodeURIComponent(startNode)}&end=${encodeURIComponent(endNode)}`;
                const response = await fetch(url);
                const result = await response.json();

                loader.style.display = 'none';

                if (result.error) {
                    outputDiv.innerHTML = `<span style='color:#e74c3c'>Erro:</span> ${result.error}`;
                    return;
                }

                outputDiv.innerHTML = result.info || "Algoritmo conclu√≠do.";

                if (result.path && result.path.length > 0) {
                    if (type === 'dijkstra' || type === 'bellman_ford') {
                        highlightPath(result.path);
                    } else {
                        animateExploration(result.path);
                    }
                }

            } catch (e) {
                loader.style.display = 'none';
                outputDiv.innerText = "Erro de conex√£o com o Python.";
                console.error(e);
            }
        }

        function handleEnter(e) {
            if (e.key === 'Enter') searchNode();
        }
        function searchNode() {
            const input = document.getElementById('searchInput');
            const name = input.value.trim();
            const output = document.getElementById('output');

            if (!name) {
                output.innerHTML = "Por favor, digite algo para buscar.";
                return;
            }

            // Restaura todas as arestas √†s cores originais antes de fazer nova busca
            if (originalProcessedEdges) {
                edgesDataset.update(originalProcessedEdges);
            }

            const lowerCaseName = name.toLowerCase();

            // Primeiro, busca nos n√≥s (artistas)
            const allNodes = nodesDataset.get();
            const foundNode = allNodes.find(n => n.label.toLowerCase().includes(lowerCaseName));

            if (foundNode) {
                network.unselectAll();
                network.selectNodes([foundNode.id]);
                network.focus(foundNode.id, {
                    scale: 1.2,
                    animation: {
                        duration: 1000,
                        easingFunction: 'easeInOutQuad'
                    }
                });

                document.getElementById('startSelect').value = foundNode.id;
                output.innerHTML = `üé§ Artista encontrado para "<strong>${name}</strong>": <br><strong>${foundNode.label}</strong>`;
                return;
            }

            // Se n√£o encontrou artista, busca nas arestas (m√∫sicas)
            const allEdges = edgesDataset.get();
            const foundEdges = allEdges.filter(e => 
                e.track_name && e.track_name.toLowerCase().includes(lowerCaseName)
            );

            if (foundEdges.length > 0) {
                network.unselectAll();
                
                // Destaca as arestas encontradas
                const edgeIds = foundEdges.map(e => e.id);
                network.selectEdges(edgeIds);
                
                // Obt√©m os n√≥s conectados para fazer zoom
                const connectedNodes = new Set();
                foundEdges.forEach(edge => {
                    connectedNodes.add(edge.from);
                    connectedNodes.add(edge.to);
                });
                const nodeIds = Array.from(connectedNodes);
                
                // Destaque visual das arestas (mant√©m a estrutura de cores original)
                const edgeUpdates = foundEdges.map(edge => {
                    const originalEdge = originalProcessedEdges ? 
                        originalProcessedEdges.find(e => e.id === edge.id) : null;
                    const baseColor = originalEdge && originalEdge.color ? 
                        originalEdge.color.color : '#1DB954';
                    
                    return {
                        id: edge.id,
                        color: {
                            color: '#1DB954',
                            highlight: '#1DB954',
                            hover: '#1DB954'
                        },
                        width: 5
                    };
                });
                edgesDataset.update(edgeUpdates);
                
                // Remove duplicatas dos nomes de m√∫sicas
                const uniqueTrackNames = [...new Set(foundEdges.map(e => e.track_name))];
                const trackNames = uniqueTrackNames.join(', ');
                const count = uniqueTrackNames.length;
                const edgesCount = foundEdges.length;
                
                // Faz zoom nos n√≥s conectados
                // Se houver apenas uma m√∫sica, faz zoom mais pr√≥ximo e focado (similar √† busca de artista)
                if (nodeIds.length > 0) {
                    if (count === 1) {
                        // Para uma √∫nica m√∫sica, usa fit para garantir que todas as arestas sejam vis√≠veis
                        network.fit({
                            nodes: nodeIds,
                            edges: edgeIds,
                            animation: {
                                duration: 1000,
                                easingFunction: 'easeInOutQuad'
                            }
                        });
                    } else {
                        // Para m√∫ltiplas m√∫sicas, usa focus com scale maior
                        network.focus(nodeIds, {
                            scale: 1.5,
                            animation: {
                                duration: 1000,
                                easingFunction: 'easeInOutQuad'
                            }
                        });
                    }
                }
                
                // Mensagem informa quantas m√∫sicas √∫nicas foram encontradas e quantas arestas
                let message = `üéµ ${count} m√∫sica${count > 1 ? 's' : ''} encontrada${count > 1 ? 's' : ''} para "<strong>${name}</strong>":`;
                if (edgesCount > count) {
                    message += ` <span style='color:#95a5a6; font-size:0.9em'>(${edgesCount} colabora√ß√£o${edgesCount > 1 ? '√µes' : '√£o'})</span>`;
                }
                message += `<br><strong>${trackNames}</strong>`;
                output.innerHTML = message;
            } else {
                output.innerHTML = `<span style='color:#e74c3c'>Nenhum artista ou m√∫sica contendo "${name}" foi encontrado no grafo.</span>`;
            }
        }

        function highlightPath(path) {
            const allNodes = nodesDataset.getIds();
            const allEdges = edgesDataset.getIds();

            nodesDataset.update(allNodes.map(id => ({ id: id, color: '#333', opacity: 0.1 })));
            edgesDataset.update(allEdges.map(id => ({ id: id, color: '#333', opacity: 0.05 })));

            const nodeUpdates = path.map((id, index) => {
                let color = '#f1c40f';
                let size = 25;
                if (index === 0) { color = '#3498db'; size = 35; }
                if (index === path.length - 1) { color = '#e74c3c'; size = 35; }

                return { id: id, color: { background: color, border: '#fff' }, opacity: 1, size: size };
            });
            nodesDataset.update(nodeUpdates);

            const edgeUpdates = [];
            for (let i = 0; i < path.length - 1; i++) {
                const u = path[i];
                const v = path[i + 1];
                const edges = network.getConnectedEdges(u);
                edges.forEach(edgeId => {
                    const edge = edgesDataset.get(edgeId);
                    if (edge.to === v || edge.from === v) {
                        edgeUpdates.push({ id: edgeId, color: '#f1c40f', width: 4, opacity: 1 });
                    }
                });
            }
            edgesDataset.update(edgeUpdates);

            if (path.length > 0) network.fit({ nodes: path, animation: true });
        }

        function animateExploration(path) {
            let i = 0;
            const allIds = nodesDataset.getIds();
            nodesDataset.update(allIds.map(id => ({ id: id, color: '#222', opacity: 0.2 })));

            function step() {
                if (i >= path.length) return;

                nodesDataset.update({
                    id: path[i],
                    color: { background: '#1DB954', border: '#fff' },
                    opacity: 1,
                    size: 25
                });

                i++;
                const delay = path.length > 500 ? 5 : 50;
                setTimeout(step, delay);
            }
            step();
        }

        function resetGraph(resetView = true) {
            const allNodes = nodesDataset.getIds();
            const allEdges = edgesDataset.getIds();

            nodesDataset.update(allNodes.map(id => ({
                id: id, color: null, opacity: 1, size: 20
            })));

            // Restaura as arestas originais processadas
            if (originalProcessedEdges) {
                edgesDataset.update(originalProcessedEdges);
            } else {
                edgesDataset.update(allEdges.map(id => ({
                    id: id, color: null, width: 2, opacity: 1
                })));
            }

            network.unselectAll();
            document.getElementById('output').innerText = "Visualiza√ß√£o limpa.";
            if (resetView) network.fit({ animation: true });
        }

        async function recarregarGrafo() {
            const response = await fetch('/api/graph');
            const data = await response.json();
            const processedEdges = processEdges(data.edges);
            originalProcessedEdges = processedEdges; // Atualiza as arestas originais

            edgesDataset.update(processedEdges);
            network.redraw(); 
        }

        async function pesoNegativo() {
            const loader = document.getElementById('loading');
            const outputDiv = document.getElementById('output');

            loader.style.display = 'block';
            outputDiv.innerText = "Negativando pesos...";
            try {
                const response = await fetch('/api/peso_negativo'); 
                const result = await response.json();

                resetGraph(false); 
                await recarregarGrafo(); 
                outputDiv.innerHTML = `<span style='color:#f39c12'>Pesos alterados!</span> ${result.message} <br>Tente rodar o **Bellman-Ford**.`;
            } catch (e) {
                outputDiv.innerText = "Erro ao negativar pesos.";
                console.error(e);
            } finally {
                loader.style.display = 'none';
            }
        }
        
        async function resetarPesos() {
            const loader = document.getElementById('loading');
            const outputDiv = document.getElementById('output');

            loader.style.display = 'block';
            outputDiv.innerText = "Resetando pesos...";
            try {
                const response = await fetch('/api/resturar_peso'); 
                const result = await response.json();
                
                resetGraph(false); 
                await recarregarGrafo();
                outputDiv.innerHTML = `<span style='color:#1DB954'>Pesos resetados!</span> ${result.message} <br>Agora o **Dijkstra** deve funcionar corretamente.`;
            } catch (e) {
                outputDiv.innerText = "Erro ao resetar pesos.";
                console.error(e);
            } finally {
                loader.style.display = 'none';
            }
        }

        function processEdges(edges) {
            return edges.map(edge => {
                let edge_color = '#444';
                let edge_width = 2;
                
                if (edge.is_negative) {
                    edge_color = '#e74c3c';
                    edge_width = 3;
                }
                
                return {
                    ...edge, 
                    width: edge_width,
                    color: {
                        color: edge_color,
                        highlight: '#1DB954',
                        hover: edge_color, 
                    },
                };
            });
        }

        window.onload = initGraph;
    
    </script>
</body>

</html>